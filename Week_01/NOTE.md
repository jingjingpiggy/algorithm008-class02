学习笔记
第三课
第一节：数组链表跳表
1. 重点思维：升纬，空间换时间

2. Array: 在频繁的增加删除过程中，Arry要做大量的重复操作
    各种操作的时间复杂度:prepend O(n), append O(n), loopup O(1), insert O(n), delete O(n)

3. Linked List: Java 中是双向链表，没有涉及群移操作，但对访问链表中的任意位置便不再简单了。
    循环链表：头尾相连
    双向链表：preview ->next
                      <-
    各种操作的时间复杂度:prepend O(1), append O(1), loopup O(n), insert O(1), delete O(1)

4. 跳表：只能用于元素有序的情况，所以跳表对标的是平衡树AVL 和 二分查找。
    最大的优势：原理简单、容易实现、方便扩展、效率更高、因此在一些项目中用来替代平衡树，如Redis、LevelDB等

5. 如何给有序的链表加速？
    一维数据结构加速的话 --->升纬，变成二维，因为多一个维度之后就会多一级的信息，可以帮助很快的定位到元素所在的范围，而这个范围在一维里面需要一个一个走才能走到的元素位置。
    跳表中查询任意数据的时间复杂度：O(logn)

6. 现实中的跳表：维护成本相对高，因为不断增加删除，导致索引不是完全工整的，每增加删除，索引都要更新一遍，增加删除为log(n)

Day1: moveZero--用双指针法是比较棒的，指针i用来遍历，指针j用来标注0的位置，当i为0时往后走，j为0时停下，当i遇到不为0时，与j进行交换，然后j++。i继续往后走。。。
                多个数组的更好解决
                关于在数组中遍历的同时更改数组。。。这个我还没想好，待补充

Day2：plusOne--加法器
               list->字符串->整行-> +1 ->整行list
               [1,2,3] -> 整数 -> sums=sums*10 +i
               注：int(map(int, list(sums_srt)))

Day3: container_with_most_water: 保证i和j不会重复也不会反复的值。时间复杂度 O（n^2）
                                 左右边界i, j同时向中间收敛(左右夹逼的办法)： 双指针双侧向内移动，谁的高度低谁往里挪。时间复杂度O（n）
      climbStairs: 爬台阶：找最近重复子问题，找重复性

Day4: 2sums and 3sums 待续：卡住了

Day5: % 求余，/ 结果包括float和int类型，//结果为int
Day6: lc977, 用到了两种方法：从头到尾遍历+原list，双指针+新list: i,j 从左右两侧计算，取大的值添加到新数组的尾部
